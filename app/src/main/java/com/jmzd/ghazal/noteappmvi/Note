پکیج بندی پروژه------------------------------------------------------------------------------------
پکیج بندی پروژه دقیقا مثل پکیج بندی MVP و MVVM است به صورت کلی
عمده فایل های پروژه مثل قبل هستن  و مستقیما از پروژه mvvm کپی شدن
(فایل های utils - di - database - server - repository )
فایل های ریپازیتوری هم عینا مثل قبل هستن چون فلسفه ریپازیتوری توی همه معماری ها یکسانه
مثلا توی اپلیکیشن های آنلاین میشه ارور کدها رو توش هندل کرد
فقط یک پکیج viewModel رو بیشتر داریم که تمام بخش های intent - state و ... میره توش
جلوتر یاد میگیریم
اصل کار این معماری داخل پکیج ویو است.
مدیریت تمام صفحات اینجا اتفاق می افته

Toolbar---------------------------------------------------------------------------------------------
نکته یادآوری:
زمانی که توی  کد از setSupportActionBar استفاده میکنیم تم ما حتما باید noActionBar باشد
در غیر این صورت با کرش رو به رو میشیم

pop up fragment-------------------------------------------------------------------------------------
یادآوری:
addNoteBtn.setOnClickListener { NoteFragment().show(supportFragmentManager, NoteFragment().tag) }
این تگی که اضافه میکردیم برای مدریت کارهای مربوط به پشته و استکه
میشه دستی یک استرینگی داد یا از تگ خود فرگمنت استفاده کرد

spinners--------------------------------------------------------------------------------------------
از تامین کردن اطلاعات داخل اسپینرها شروع میکنیم
دیتای اسپینرها رو خودمون قراره تولید کنیم
ولی به هر  حال قراره از یک جای دیگه تامین شه
توی توضیحات MVI گفتیم که ویو (اکتیویتی - فرگمنت) کارهای مربوط به دیتا و اینجور چیزا رو انجام نمیده
کلا ایده ای هم نداره که این اطلاعات از کجا میاد و کجا میره
صرفا یه سری متد رو فراخوانی میکنه

توی MVVM چیکار میکردیم؟
میومدیم این اطلاعات رو داخل ویومدل مینوشتیم
چون هندل کردن و تامین دیتای ویو با ویومدل بود

ما توی MVI ویومدل رو داریم و دقیقا همون تعریف و عملکردی رو داره که توی MVVM داشت

از طرفی چیزهای دیگه ای هم نیاز داریم. چه چیزی؟
گفتیم به اینتنت نیاز داریم
که به ما کمک میکنه که بفهمیم توی این صفحه مورد نظر به چه عملیاتی نیاز داریم

#State
بعد از اون طبق اسلایدها به مدل نیاز داریم
که گقتیم وظیفه ش مدیریت کردن وضعیت یا state های برنامه ماست
مثلا چه state هایی داریم؟
توی سناریوی اسپینرها نیاز به یک state دارم که بفهمم اطلاعات این اسپینرها تامین شده یا خیر
اگر تامین شده و اطلاعات رو داره بیاد به ویو بده

اینکه ویو قراره چطوری این اطلاعات رو به کاربر نشون بده دیگه ربطی به مدل نداره

پس من به یک stateی نیاز دارم که بفهمم اولا اطلاعات این تامین شده یا نه که بتونم باش کار کنم
و state بعدی اینه که ممکنه با ارور رو به رو شم.
مثلا روی دکمه سیو که میزنم دیتابیس بترکه یا هر چی.
پس یک state هم دارم که بتونم به کابر ارور احتمالی رو نشون بدم

مورد بعدی اینکه روی دکمه سیو که زد ذخیره شده یا نه؟
به واسطه اون مثلا توست نشون بدم یا صفحه رو ببندم

چون state یه ذره راحت تر بود اول گفتیمش
ولی به ترتیب که بیایم کاربر اول با اینتنت کار داره بعد مدل بعد ویو

#Intent
چطور باید اینتنت ها رو تشخیص بدم؟
اینتنت گفتیم عملیات یا اکشن های مختلف است
گفتیم این اکشن ها یا عملیات ها یا میتونن توسط کاربر ایجاد بشن یا میتونن توسط خود سیستم (من برنامه نویس) ایجاد بشن
مثلا به محض ورود کاربر به صفحه این اطلاعات لود بشه
توسط کاربر هم که میشه مثلا وقتی میزنه روی یک دکمه ای
مثلا حتی میشد دکمه ضربدر بستن صفحه رو با اینتنت ها هندل کرد
ولی کارمون پیچیده و طولانی میشد
یکی از ایراداتی که به MVI میگیرن همینه که اینقدر برای حالت های مختلف اکشن و استیت تعریف کردن
یعنی شما باید برای کوچک ترین حالت هم اکشن و استیت تعریف کنید
همین دکمه ضربدر باید یک اکشن و یک استیت میداشت مثلا
آدم اذیت میشه
هدف از استفاده از معماری ها اینه بمون کمک کنه و در صورتی که ببینیم اذیت میشیم میذاریمش کنار
ما هندل کردنشو یاد میگیریم ولی افراط نمیکنیم
چون کد رو شلوغ میکنه و حالت کثیف MVI میشه این. ما میخوایم یه MVI تر و تمیز و اصولی داشته باشیم

اولین اینتنتی که داریم توی سناریومون چیه؟
اطلاعات اسپینرها باید لود بشه
به محض ورود کاربر به صفحه صدا زده میشه

دومین اینتنتی که نیاز دارم چیه؟
زمانی که روی این دکمه سیو زد کاربر اطلاعات توی دیتابیس باید ذخیره شه

پایان توضیحات اولیه-------------------------------------------------------------------------------
داخل پکیج ویومدل به ازای هر صفحه ای که داریم یک پکیج میسازیم که مواردش میره داخلش

#Intent
کلاس اینتنت رو از نوع sealed class تعریف میکنیم نه کلاس عادی

sealed class :
به معنی کلاس مهر و موم شده است
ولی کارش چیه؟
وقتی میخوایم حالت های مختلف رو تعریف کنیم ولی فقط از یکیش استفاده کنیم
تقریبا شبیه enum است
نمیشه ازش آبجکت ساخت و برای استفاده باید ازش ارث بری کرد
توش میشه متد نوشت و بعد به متدها مثل استاتیک دسترسی پیدا کرد

حالا میایم اکشن هایی که بالاتر تحلیل کردیم نیاز داریم رو داخل این sealed class تعریف میکنیم
برای هر اکشنی از خودتون بپرسید: آیا من نیاز به ورودی دارم؟
مثلا برای دریافت اطلاعات اسپینر : خیر
برای سیو کردن : بله (مدل نوت)

میتونیم این اکشن ها را به صورت دیتا کلاس تعریف کنیم.

data class :
 کلاسیه که یک سری ورودی ها داره.
مثل setter & getter توی جاوا. که اینجا نیازی بهشون نداریم

پس ما داخل sealed class موارد رو در قالب کلاس تعریف میکنیم.
حالا یک راهش دیتا کلاسه و یک راه دیگه هم هست که جلوتر یاد میگیریم
پس به صورت فانکشن تعریف نمیکنیم

نکته خیلی مهم:
وقتی داریم از sealed class استفاده میکنیم حتما از اینتنت خودشون ارث بری کنن
خیلی  حواستون باشه. بعدا تعداد کلاس ها و ایناتون میره بالا مثلا اشتباهی از stateش ارث بری نکنید.
ارجاع بدید به خود همون sealed class

 data class SpinnerList() : DetailIntent()
وقتی به شکل بالا تعریف میکنیم و هیچ ورودی ای نداریم ارور میده که تو دیتا کلاس تعریف کردی ولی ورودی نداری هیچی
میشه کلاس ساده ش کرد که ارور نده. ولی راه حل اصلی چیه؟
این یک نکته کاتلینیه:
کافیه تبدیلش کنیم به آبجکت و پرانتزش هم حذف کنیم. آبجکت هیچ ورودی ای نداره
 object SpinnerList : DetailIntent()
این مثل حالت قل عمل میکنه بدون اینکه هیچ وارنینیگی نشون بده

پس شد:
 اگه ورودی نداشت آبجکت تعریف میکنیم بدون پرانتز اگه ورودی داشت دیتا کلاس
در هر دو صورت از اینتنت خودشون ارث بری مییکنن
چون کلاسن اسمشون با حروف بزرگ نوشته میشه

اگه ارجاع ندید به اینتنت ارور نمیگیرید الان ولی بعدا موقع استفاده نمیشناسه

#State
استیت هم sealed class است.
اینجا هم با منطق مشابه اگه قراره چیزی فرستاده شه به ویو با دیتاکلاس تعریف میکنیم
اگه نه آبجکت
از استیت خودش ارث بری میکنه

نکته:
ما دو تا اسپینر داریم.
میتونیم دو  تا کلاس جدا برا استیت هاشون تعریف کنیم
ولی اینا رو هم زمان میخوایم
و با توجه به اینکه میخوایم از کانال های کروتین استفاده کنیم و ویژگی هاشون
و نمیخوایم دیلی هم بندازیم اول اینو بفرس بعد اونو
پس میایم چیکار میکنیم؟
اون دو تا چیزی که قراره با هم هم زمان اتفاق بیفتن
ورودی هاشون را با هم در یک کلاس در نظر میگیریم
این دو تا خیلی شبیه همن. نحوه تامین اطلاعاتشون. هم زمان اتفاق می افتن...
به این هم زمانی خیلی دقت کنید...

#ViewModel
ساختار کلیش همون ویومدل خودمونه
قبلا توی ویومدل چیکار میکردیم؟
یک لایو دیتا تعریف میکردیم و یک فانکشن. هر جا لازم داشتیم ابزروش میکردیم و لایف سایکلشو بهش میدادیم.
ولی اینجا یه خرده متفاوته. چیا متفاوته؟
اینجا از کانال های کروتین استفاده میکنیم و توی ویومدل هندلشون میکنیم.
دقت کنید که ویو در این حالت فقط دریافت کننده اطلاعات از کانال خواهد بود و نه فرستنده

دومین چیزی که نیاز دارم stateFlow است.
درواقع stateFlow تقریبا شبیه لایو دیتاست ولی مال کتابخونه فلو است.

توی این پروژه از فلو و کروتین استفاده میکنیم و استفاده ای از لایو دیتا نمیکنیم

1-
val detailIntent = Channel<DetailIntent>()
اولین کاری که میکنیم یک کانال تعریف میکنیم
نکته خیلی مهم: کانالی که ایمپورت میکنید حتما از نوع اینترفیس و از کتابخونه کروتین باشه.
دیتا تایپش باید از نوع اینتنت ما باشه. چون اینتنت همون اکشن هاییه که باید در اون صفحه انجام بگیره
یادآوری: پرانتز کانال تعیین کننده نوع اون کاناله
ما از روندیوی استفاده میکنیم چون میخوام این اطلاعاتی که دارم میفرستم منتظر بمونه گیرنده اطلاعات رو بگیره
چون مثلا میخوام اطلاعات اسپینر رو بفرستم و مطمعن شم گیرنده گرفته که برم سراغ چیزهای دیگه
نمیخوام منتظر چیز دیگه ای باشم
مثلا وقتی سیو رو زد میخوام بلافاصله نتیجه کارش رو ببینه
مثل بافر نباشه که کارها منتظر بمونن...
این بستگی به سناریومون داره البته که از چه نوع کانالی استفاده کنیم

2-
اگه یادتون بیاد تو پروژه های قبلی که کار میکردیم میومدیم از mutable هر چیزی استفاده میکردیم
چه لیست چه لایو دیتا...
مثلا یک mutableLiveData توی ویومدل تعریف میکردیم و هر جا میخواستیم ازش استفاده کنیم مستقیم به همون دسترسی پیدا میکردیم
و طبق اصول کلین کد این متغیر کار خودشو انجام میده و اطلاعات توش safe میمونه
اون چیزی که میخوایم اصل اطلاعاتمون روش قرار بگیره میایم از حالت میوتبل استفاده میکنیم براش

توی اون روش بست پرکتیس بایندینگ میومدیم این متغیر بایندینگ  رو تعریف میکردیم
بعد میومدیم یک متغیر دیگه هم تعریف میکردیم که آخرین state اون متغیر اولی رو میگرفت
بعد هر جا میخواستیم اون متغیر اولیه رو پر و خالی میکردیم
در واقع هر جا میخواستیم set کنیم از متغیر اولی استفاده میکردیم
هر جا هم میخواستیم استفاده کنیم و get کنیم میومدیم از متغیر دومی استفاده میکردیم

توی کار با لایودیتاها هم میتونستیم از روش بالا استفاده کنیم
میومدیم یک mutableLiveData رو تعریف میکردیم
اون چیزی که قراره توش پر بشه رو داخلش میذاریم
یک متغیری از جنس همون بدون میوتبل از نوع لایو دیتای خالی تعریف میکنیم و آخرین وضعیت اینو میریزیم توش
بعد از اون استفاده میکنیم.
هر جا اینو آپدیت میکنیم آخرین وضعیتش ریخته میشه تو متغیر دوم

حالا توی این پروژه هم میخوایم از همین سیستم استفاده کنیم و ببریم جلو
[توی این روش کسی که استفاده میکنه از اون متغیر اصلا اجازه دسترسی و تغییر دادن اطلاعات رو نداره و خیلی کلین کد تره]
اگه خواستید از لایو دیتا استفاده کنید هر جا از stateFlow استفاده شده در این پروژه میتونید از لایو دیتا استفاده کنید.
mutableStateFlow = mutableLiveData
stateFlow = liveData

برای اینتنت ها از کانال استفاده میکنیم
برای استیت ها از کانال استفاده نمیکنیم
چرا؟
کانال برای زمانیه که با اینتنت ها کار میکنیم
چون اینتنت ها اکشن های اصلی ما هستن که داره روشون کاری صورت میگیره
ما از کانال استفاده میکنیم که بتونیم روی اونا اطلاعاتمون رو بتونیم سند کنیم و دریافت کنیم و استفاده کنیم

معمولا اسم اون متغیر اصلیه که دسترسی محدود داره رو با آندرلاین مینویسیم

private val _state = MutableStateFlow<DetailState>(DetailState.Idle)
val state: StateFlow<DetailState> get() = _state

توجه داشته باشید که StateFlow ی که ایمپورتت میکنید هم از نوع اینترفیس و از کتابخانه کروتین باشه

stateFlow vs sharedFlow:----------------------------------------------------------------------------
(البته نحوه استفاده کردنشون یکم متفاوته)

استیت فلو برای حالتیه که
 ما اون وضعیت رو میگیریم
  و یک سری اطلاعات رو دریافت میکنیم
   و ازش میخوایم استفاده کنیم.

شیرد فلو برای حالتیه که
یک کاری میخواد انجام بگیره
مثلا یک حالت کال بک داره
مثلا روی دکمه کلیک کن. همین
یک توست رو نشون بده. همینو بس
هیچ حالت برگشتی ای نداره که مثلا بخواد استفاده کنه

[احتمالا بیشتر برای مدیریت ایونت ها مورد استفاده قرار میگیره]
[برای جا به جایی دیتا باید از استیت فلو استفاده کرد]
در کل میشه به جای هم استفاده شون کرد ولی بهتره هر کسی برای همون کاری که ساخته شده مورد استفاده قرار بگیره
----------------------------------------------------------------------------------------------------
برمیگردیم به کد خودمون
private val _state = MutableStateFlow<DetailState>(DetailState.Idle)
val state: StateFlow<DetailState> get() = _state

یه وقت نگید چون داریم استیت ها رو مدیریت میکنیم از استیت فلو استفاده میکنیما؟
نه این میتونست اصلا لایو دیتا باشه. ربطی نداره. حتی یک درصد. مثل جاوا و جاوا اسکریپت

#DetailState.Idle ?
اگه از لایو دیتا استفاده میکردیم لازم نبود توی پرانتزش چیزی رو پر کنیم.
ولی وقتی از استیت فلو استفاده میکنیم لازمه که توی کانستراکتورش یک چیزی رو بفرستیم
چه چیزی حالا؟
هر چیزی که داخل کلاس DetailState باشه
به شرط اینکه اون کلاس اصلی از نوع sealed class باشه
و همه اون مواردی که میخوایم استفاده کنیم از اون کلاس sealed class ارث بری کرده باشن

وقتی میزنیم DetailState. بعد از دات لیست تمام کلاس های داخلیش رو میاره و میتونیم دسترسی داشته باشیم
مثلا DetailState.SpinnersData
DetailState.Error
DetailState.SaveNote
ولی مثلا اگه SpinnersData رو بزنیم دو تا ورودی هم داره که باید بهش بدیم این دو تا ورودی رو
ارور هم همینطوره ورودی داره
ولی اگه سیو رو بنویسیم چون آبجکته ورودی نمیخواد و قبول میکنه ازمون

ولی اون چیزی که قراره توی پرانتز بدیم در واقع اون حالت پیش فرضه است
چرا میخوادش؟
میگه مثلا همون اول که اومد این فلویی که داری استفاده میکنی
اب توجه به کدوم یکی از این عملیات هایی که داری استیتت ساخته بشه
مثلا وقتی اطلاعات رو از سرور میگیریم استیت پیش فرض ما لودینگ میشه
ما توی سناریوی الانمون اون حالت پایه رو نداریم
یک راه الکی و روش دور زدن
یک حالت idle یا حالت خنثی تعریف میکنن
و میگن وقتی شما اون حالت پیش فرضه رو ندارید بیا از این حالت خنثی برای من استفاده کن
این حالت خنثی جیه؟ هیچ کاری نمیکنه
فقط میخواد اون حالت خنثثی عه رو به این وضعیت بده که بفهمه اون حالت اولیه ش با چه چیزی باید ساخته بشه
[دقیقا مثل اون حالت initial توی بلاک ]
پس میریم این idle رو توی استیت هامون به عنوان یک آبجکت تعریف میکنیم

پس زمانی که ما هیچ پیش فرضی نداریم
مثل حالت لودینگ یا خالی
یک حالت خنثی براش در نظر میگیریم که ست کنیم
----------------------------------------------------------------------------------------------------
private val _state = MutableStateFlow<DetailState>(DetailState.Idle)
val state: StateFlow<DetailState> get() = _state
در نهایت اون حالت getter رو تعریف میکنیم
 که برعکس  خط بالایی که پرایویت و فقط در دسترس ویومدل است
 پابلیک است و در اختیار همه است
 میوتبل نیست
 mutable = editable
----------------------------------------------------------------------------------------------------
تا اینجای کار نحوه تعریف استیت و اینتنت در ویومدل رو یاد گرفتیم
حالا میخوایم نحوه کار کردن اینا با هم دیگه رو یاد بگیریم
که مثلا وقتی اینتنت فلان صدا زده شد چطور بره استیت فلان رو اجرا کنه

 private fun handleIntents() = viewModelScope.launch {
        detailIntent.consumeAsFlow().collect { intent ->
            when (intent) {
                is DetailIntent.SpinnersList -> fetchingSpinnersList()
                is DetailIntent.SaveNote -> savingData(intent.entity)
                is DetailIntent.NoteDetail -> fetchingNoteDetail(intent.id)
                is DetailIntent.UpdateNote -> updatingData(intent.entity)
            }
        }
    }

# private fun handleIntents()
همه چیز قراره داخل این ویومدل اتفاق بیفته و ویو هیچ اطلاعی از اون نداره.
واسه همین پرایویت تعریف میکنیم فانکشن رو

# viewModelScope.launch
چرا از این اسکوپ استفاده میکنیم؟
چون میخوایم از کانال های کروتین استفاده کنیم
برای استفاده از کروتین یا باید داخل ساسپند فانکشن باشیم یا داخل اسکوپ های مربوط به کروتین
تنها اسکوپ کاربردی توی ویومدل همین ویومدل اسکوپ است

# detailIntent.consumeAsFlow().collect
فلو برای ما چه کاری انجام میداد؟
فلو جریان داده منه.
یعنی وقتی آپدیت میشه نباید مدام چکش کنم اتفاق افتاده؟ اتفاق افتاده یا نه؟
هر موقع اتفاق افتاد خودش بهمون اطلاع میده
پس این جریان داده ست و ما توسط کالکت این اطلاعات رو دریافت میکنیم

و من برای اینکه بفهمم دقیقا کدوم یکی از این ها اتفاق افتاده
 و مدام نخوام چک کنم ببینم اتفاق افتاده یا نه
هر موقع اتفاق افتاد بفهمم
من که نمیدونم کاربر کی میخواد بزنه روی دکمه سیو؟
میخوایم بگیم هر موقع اتفاق افتاد...
پس از فلو استفاده میکنیم و برای اینکه اطلاعات رو از فلو دریافت کنیم هم نیاز به کالکت داریم

ولی کانال جزو کروتین است.
من برای اینکه کروتینم رو تبدیل کنم به فلو
consume = مصرف کننده
مصرف کننده اش رو تبدیل میکنیم به فلو

از اینجا به بعد هر وقت اکشنی اتفاق افتاد خیلی راحت با جریان داده خبردار میشیم

# when (intent)
این it ی که به ما برمیگرده یک intent است از جنس DetailIntent
به این ترتیب هر زمان یک اینتنتی اتفاق بیفته ما کدهای مربوط به اون رو انجام میدیم

#
_state.value = DetailState.SpinnersData(categoriesList, prioritiesList)
_state.emit(DetailState.SpinnersData(categoriesList, prioritiesList))
خب استیت آندرلاین دار همون میوتبل editable بود که توی ویومدل دسترسی داشتیم و باید ادیتش کنیم
بعد آخرین وضعیتش ریخته میشه توی اون متغیر پابلیکه

value vs emit:
فلو مثل لایو دیتا دو تا حالت داره برای فرستادن اطلاعات
وقتی از value استفاده میکنیم باید از = استفاده کنیم و اطلاعات رو مساوی اون مقدار قرار بدیم
وقتی از emit استفاده میکنیم باید تبدیل به ساسپند فانکشن بشه این فانکشنمون یا باید اسکوپ بدیم
که بالاتر اسکوپ هم تعریف کردیم (ویومدل اسکوپ)
فقط کافیه ساسپندش کنیم پس
یا اصلا

private fun fetchingSpinnersList() {
تبدیل بشه به
private fun fetchingSpinnersList() = viewModelScope.launch {
یا
private suspend fun fetchingSpinnersList() {

----------------------------------------------------------------------------------------------------
 private fun savingData(entity: NoteEntity) = viewModelScope.launch {
     _state.value = try {
         DetailState.SaveNote
         یا
         DetailState.SaveNote(repository.saveNote(entity))
     } catch (e: Exception) {
         DetailState.Error(e.message.toString())
     }
 }

نکته در مورد try catch
اگر نوع اروری که قراره بگیرید رو میدونید بنویسید
در غیر این صورت کلی بنویسید. چون اگه اشتباه بنویسید نوعشو کلا براتون هندل نمیکنه

میشد ry catch رو به این شکل هم نوشت:
     try {
       _state.value =  DetailState.SaveNote
         یا
       _state.value =  DetailState.SaveNote(repository.saveNote(entity))
     } catch (e: Exception) {
       _state.value =  DetailState.Error(e.message.toString())
     }
ولی روش حرفه ای تر و کاتلینیش همون روشیه که  بالا نوشتیم

ولی نکته اصلی این کد:
       _state.value =  DetailState.SaveNote
         یا
       _state.value =  DetailState.SaveNote(repository.saveNote(entity))
وقتی استیت ها رو تعریف میکردیم گقتیم state سیو نوت که ورودی نداره!
پس به صورت آبجکت نوشتیمش
ولی ورودی داره یک ورودی خیلی مهم هم داره

عملیات سیو نیاز به ریپازیتوری داره چونکه...

[من توی بلاک البته ورودی نمیدادم و عملیات رو مستقل انجام میدادم.
 نتیجه رو امیت میکردم. اینم یک راهشه پس...]

#repository.saveNote(entity)
چون متد saveNote داخل ریپازیتوری ساسپند فانکشن است
 پس این متد savingData هم یا باید ساسپند باشه یا اسکوپ بگیره...
----------------------------------------------------------------------------------------------------
توی استیت ها میایم save نوت رو اصلاح میکنیم که ورودی رو بگیره
object SaveNote : DetailState()
تبدیل میشه به
data class SaveNote(val unit : Unit) : DetailState()
ورودیش باید از نوع unit باشه که معادل همون void توی جاواست
یعنی ورودی ای که هیچ مقدار بازگشتی ای نداره
چرا؟
چون متد repository.saveNote(entity) هیچ چیزی را به من برگشت نمیده
صرفا عملیات سیو رو انجام میده
